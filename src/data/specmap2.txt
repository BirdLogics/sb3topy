"""

"""

import asyncio
import math
import random

import engine

#pylint: disable=all

# flags:
# -d1 Means the sprite will become dirty after running
# -d2 Means the rectangle will need updating after running
# -d3 Means the image will need updating after running

# -s1 Means that dirty must be set before running the block
# -s2 Means the block accepts and sets {DIRTY}
# -y  Means the block should yield after its substack

# -h  Means the block is a hat and requires special parsing


# Expression to use for -y
#: code_yield
await self.yield_()

#: special_unkown
pass # unkown opcode

#: special_pen
self.pen.move()

#: procedures_definition (any custom_block) -h
procedure
    {custom_block}

#: any argument_reporter_string_number (any VALUE)
{VALUE}

#: any argument_reporter_boolean (any VALUE)
{VALUE}

#: stack procedures_call (string NAME, list PARAMETERS) -s1
await {NAME}({PARAMETERS})

#: stack motion_movesteps (float STEPS)
self.move({STEPS})

#: stack motion_turnright (float DEGREES)
self.direction += {DEGREES}

#: stack motion_turnleft (float DEGREES)
self.direction -= {DEGREES}

#: stack motion_pointindirection (float DIRECTION)
self.direction = {DIRECTION}

#: stack motion_pointtowards (string TOWARDS)
self.point_towards(util, {TOWARDS})

#: stack motion_gotoxy (float X, float Y)
self.gotoxy({X}, {Y})

#: stack motion_goto (string TO)
self.goto(util, {TO})

#: stack motion_glidesecstoxy (float SECS, float X, float Y)
await self.glide({SECS}, {X}, {Y})

# TODO Glide to target?

#: stack motion_changexby (float DX)
self.xpos += {DX}

#: stack motion_setx (float X)
self.xpos = {X}

#: stack motion_changeyby (float DY)
self.ypos += {DY}

#: stack motion_sety (float Y)
self.ypos = {Y}

#: stack motion_ifonedgebounce ()
self.bounce_on_edge()

#: stack motion_setrotationstyle (string STYLE)
self.costume.rotation_style = {STYLE}

#: float motion_xposition ()
self.xpos

#: float motion_yposition ()
self.ypos

#: float motion_direction ()
self.direction

#: stack looks_sayforsecs (string MESSAGE, float SECS)
pass # looks_sayforsecs({MESSAGE}, {SECS})

#: stack looks_say (string MESSAGE)
pass # looks_say({MESSAGE})

#: stack looks_thinkforsecs (string MESSAGE, float SECS)
pass # looks_thinkforsecs({MESSAGE}, {SECS})

#: stack looks_think (string MESSAGE)
pass # looks_think({MESSAGE})

#: stack looks_show () -d1
self.shown = True

#: stack looks_hide () -d1
self.shown = False

#: stack looks_switchcostumeto (any COSTUME) -d3
self.costume.switch({COSTUME})

#: stack looks_nextcostume () -d3
self.costume.next()

#: stack looks_switchbackdropto (any BACKDROP) -d3
util.sprites.stage.costume.switch({BACKDROP})
util.send_event('onbackdrop_' + util.sprites.stage.costume.name, True)

#: stack looks_switchbackdroptoandwait (any BACKDROP) -d3s1
util.sprites.stage.costume.switch({BACKDROP})
await util.send_event('onbackdrop_' + util.sprites.stage.costume.name, True)

#: stack looks_nextbackdrop ()
util.sprites.stage.costume.next()
util.send_event('onbackdrop_' + util.sprites.stage.costume.name, True)

#: stack looks_changeeffectby (string EFFECT, float CHANGE) -d3
self.costume.change_effect({EFFECT}, {CHANGE})

#: stack looks_seteffectto (string EFFECT, float VALUE) -d3
self.costume.set_effect({EFFECT}, {VALUE})

#: stack looks_cleargraphiceffects () -d3
self.costume.clear_effects()

#: stack looks_changesizeby (float CHANGE)
self.costume.size += {CHANGE}

#: stack looks_setsizeto (float SIZE)
self.costume.size = {SIZE}

#: stack looks_gotofrontback (string FRONT_BACK)
#? looks_goto{FRONT_BACK}
pass # looks_gotofrontback()

#: stack looks_goto'front' ()
self.front_layer(util)

#: stack looks_goto'back' ()
self.back_layer(util)

# TODO Decimal behavior
#: stack looks_goforwardbackwardlayers (field FORWARD_BACKWARD, int NUM)
#? looks_go{FORWARD_BACKWARD}layers
0$

#: stack looks_go'forward'layers (int NUM)
self.change_layer(util, {NUM})

#: stack looks_go'backward'layers (int NUM)
self.change_layer(util, -{NUM})

#: int looks_costumenumbername (field NUMBER_NAME)
#? looks_costume_{NUMBER_NAME}
0$

#: int looks_costume_'number' ()
self.costume.number

#: string looks_costume_'name' ()
self.costume.name

#: int looks_backdropnumbername (field NUMBER_NAME)
#? looks_backdrop_{NUMBER_NAME}
0$

#: int looks_backdrop_'number' ()
util.sprites.stage.costume.number

#: string looks_backdrop_'name' ()
util.sprites.stage.costume.name

#: int looks_size ()
round(self.costume.size)

#: stack sound_play (any SOUND_MENU)
self.sounds.play({SOUND_MENU})

#: stack sound_playuntildone (any SOUND_MENU) -s1
await self.sounds.play({SOUND_MENU})

#: stack sound_stopallsounds ()
self.sounds.stop_all()

#: stack sound_changevolumeby (float VOLUME) 
self.sounds.change_volume({VOLUME})

#: stack sound_setvolumeto (float VOLUME) 
self.sounds.set_volume({VOLUME})

#: float sound_volume ()
self.sounds.volume

#: stack sound_seteffectto (field EFFECT, float VALUE)
self.sounds.set_effect({EFFECT}, {VALUE})

#: stack sound_changeeffectby (field EFFECT, float VALUE)
self.sounds.change_effect({EFFECT}, {VALUE})

#: stack sound_cleareffects
self.sounds.clear_effects()

#: stack pen_clear ()
self.pen.clear_all()

#: stack pen_stamp ()
self.pen.stamp(util)

#: stack pen_penDown ()
self.pen.down()

#: stack pen_penUp ()
self.pen.up()

#: stack pen_setPenColorToColor (any COLOR)
self.pen.exact_color({COLOR})

#: stack pen_changePenColorParamBy (string COLOR_PARAM, float VALUE)
self.pen.change_color({COLOR_PARAM}, {VALUE})

#: stack pen_setPenColorParamTo (string COLOR_PARAM, float VALUE)
self.pen.set_color({COLOR_PARAM}, {VALUE})

#: stack pen_changePenSizeBy (float SIZE)
self.pen.change_size({SIZE})

#: stack pen_setPenSizeTo (float SIZE)
self.pen.set_size({SIZE})

# Legacy blocks
#: stack pen_setPenShadeToNumber (float SHADE)
self.pen.set_shade({SHADE})

#: stack pen_changePenShadeBy (float SHADE)
self.pen.change_shade({SHADE})

#: stack pen_setHueTo (float HUE)
self.pen.set_hue({HUE})

#: stack pen_changePenHueBy (float HUE)
self.pen.change_hue({HUE})

#: event_whenflagclicked (stack SUBSTACK) -h
green_flag
    {SUBSTACK}

#: event_whenkeypressed (stack SUBSTACK, field KEY_OPTION) -h
key_{KEY_OPTION}_pressed
    {SUBSTACK}

#: event_whenthisspriteclicked (stack SUBSTACK) -h
sprite_clicked
    {SUBSTACK}

#: event_whenstageclicked (stack SUBSTACK) -h
sprite_clicked
    {SUBSTACK}

#: event_whenbackdropswitchesto (stack SUBSTACK, field BACKDROP) -h
onbackdrop_{BACKDROP}
    {SUBSTACK}

#: event_whengreaterthan (stack SUBSTACK, field WHENGREATERTHANMENU, float VALUE) -h
#? event_whengreaterthan_{WHENGREATERTHANMENU}
event_whengreaterthan
    while not {VALUE} > util.timer():
        await self.yield_()
        {SUBSTACK}

#: event_whenbroadcastreceived (stack SUBSTACK, field BROADCAST_OPTION) -h
broadcast_{BROADCAST_OPTION}
    {SUBSTACK}

#: stack event_broadcast (string BROADCAST_INPUT)
util.send_broadcast({BROADCAST_INPUT})

#: stack event_broadcastandwait (string BROADCAST_INPUT) -s1
await util.send_broadcast({BROADCAST_INPUT})

#: stack control_wait (float DURATION) -s1
await self.sleep({DURATION})

#: stack control_repeat (intR TIMES, stack SUBSTACK) -s1y
for _ in range({TIMES}):
    {SUBSTACK}

#: stack control_forever (stack SUBSTACK) -s1y
while True:
    {SUBSTACK}

#: stack control_if (bool CONDITION, stack SUBSTACK) -s1
if {CONDITION}:
    {SUBSTACK}

#: stack control_if_else (bool CONDITION, stack SUBSTACK, stack SUBSTACK2) -s1
if {CONDITION}:
    {SUBSTACK}
else:
    {SUBSTACK2}

#: stack control_wait_until (bool CONDITION) -s1
while not {CONDITION}:
    await self.yield_()

#: stack control_repeat_until (bool CONDITION, stack SUBSTACK) -s1y
while not {CONDITION}:
    {SUBSTACK}

# TODO Stop other scripts
#: stack control_stop (field STOP_OPTION)
#? control_stop_{STOP_OPTION}
5$

#: stack control_stop_'this_script' (field STOP_OPTION)
return None

#: stack control_stop_'other_scripts_in_sprite' (field STOP_OPTION)
self.stop_other()

#: stack control_stop_'all' (field STOP_OPTION)
util.stop_all()
return None

# TODO Clones
#: stack control_start_as_clone (stack SUBSTACK) -h
clone_start
    {SUBSTACK}

#: stack control_create_clone_of (string CLONE_OPTION)
self.create_clone_of(util, {CLONE_OPTION})

#: stack control_delete_this_clone ()
self.delete_clone(util)

#: bool sensing_touchingobject (field TOUCHINGOBJECTMENU) -u
#? sensing_touching
self.get_touching(util, {TOUCHINGOBJECTMENU})

# TODO Color detection?
#: bool sensing_touchingcolor (color COLOR) -u
False

#: bool sensing_coloristouchingcolor (color COLOR, color COLOR2) -u
False

#: float sensing_distanceto (field DISTANCETOMENU)
self.distance_to(util, {DISTANCETOMENU})

# TODO sensing_askandwait
#: stack sensing_askandwait (string QUESTION)
answer = input({QUESTION})

#: string sensing_answer
answer

#: bool sensing_keypressed (field KEY_OPTION)
util.inputs[{KEY_OPTION}]

#: bool sensing_mousedown ()
util.inputs.mouse_down

# TODO Mouse stage coords
#: int sensing_mousex ()
util.inputs.mouse_x

#: int sensing_mousey ()
util.inputs.mouse_y

#: int sensing_loudness ()
0

#: bool sensing_loud ()
False

# TODO timer
#: float sensing_timer ()
util.timer()

#: stack sensing_resettimer ()
util.timer.reset()

# TODO {OBJECT} Stage = _stage_
# TODO Properties such 
#: any sensing_of (field PROPERTY, field OBJECT) -v
#? sensing_{PROPERTY}_of
util.sprites[{OBJECT}].{PROPERTY}

#: float sensing_var_xposition_of (field PROPERTY, field OBJECT)
util.sprites[{OBJECT}].xpos

#: float sensing_var_yposition_of (field PROPERTY, field OBJECT)
util.sprites[{OBJECT}].ypos

#: float sensing_var_direction_of (field PROPERTY, field OBJECT)
util.sprites[{OBJECT}].direction

#: int sensing_var_costume_of (field PROPERTY, field OBJECT)
util.sprites[{OBJECT}].costume.number

#: string sensing_var_costumename_of (field PROPERTY, field OBJECT)
util.sprites[{OBJECT}].costume.name

#: int sensing_var_size_of (field PROPERTY, field OBJECT)
round(util.sprites[{OBJECT}].costume.size)

#: float sensing_var_volume_of (field PROPERTY, field OBJECT)
util.sprites[{OBJECT}].volume

#: int sensing_var_backdrop_of (field PROPERTY, field OBJECT)
round(util.sprites[{OBJECT}].costume.number)

#: string sensing_var_backdropname_of (field PROPERTY, field OBJECT)
util.sprites[{OBJECT}].costume.name

#: int sensing_current (field CURRENT_MENU)
#? sensing_current_{CURRENT_MENU}
0

#: sensing_current_'year'
time.localtime()['tm_year']

#: sensing_current_'month'
time.localtime()['tm_month']

#: sensing_current_'date'
time.localtime()['tm_mday']

#: sensing_current_'day of week'
(time.localtime()['tm_wday'] + 2)

#: sensing_current_'hour'
time.localtime()['tm_hour']

#: sensing_current_'minute'
time.localtime()['tm_min']

#: sensing_current_'second'
time.localtime()['tm_sec']

# TODO Diffrent epoches?
#: float sensing_dayssince2000 ()
(time.time() / 86400 - 10957)

#: string sensing_username ()
config.USERNAME

#: float operator_add (float NUM1, float NUM2)
({NUM1} + {NUM2})

#: float operator_subtract (float NUM1, float NUM2)
({NUM1} - {NUM2})

#: float operator_multiply (float NUM1, float NUM2)
({NUM1} * {NUM2})

#: float operator_divide (any NUM1, any NUM2)
div({NUM1}, {NUM2})

#: float operator_random (float FROM, float TO)
pick_rand({FROM}, {TO})

# TODO Only string if one can't be casted
#: bool operator_lt (any OPERAND1, any OPERAND2)
lt({OPERAND1}, {OPERAND2})

#: bool operator_equals (any OPERAND1, any OPERAND2)
eq({OPERAND1}, {OPERAND2})

#: bool operator_gt (any OPERAND1, any OPERAND2)
gt({OPERAND1}, {OPERAND2})

#: bool operator_and (bool OPERAND1, bool OPERAND2)
({OPERAND1} and {OPERAND2})

#: bool operator_or (bool OPERAND1, bool OPERAND2)
({OPERAND1} or {OPERAND2})

#: bool operator_not (bool OPERAND)
not {OPERAND}

#: string operator_join (string STRING1, string STRING2)
({STRING1} + {STRING2})

#: string operator_letter_of (int LETTER, string STRING)
letter_of({STRING}, {LETTER})

#: int operator_length (string STRING)
len({STRING})

#: bool operator_contains (string STRING1, string STRING2)
({STRING2} in {STRING1})

#: float operator_mod (float NUM1, float NUM2)
({NUM1} % {NUM2})

#: int operator_round (intR NUM)
{NUM}

#: float operator_mathop (string OPERATOR, float NUM)
#? operator_mathop_{OPERATOR}
0$

#: int operator_mathop_'abs' (float NUM)
abs({NUM})

#: int operator_mathop_'floor' (float NUM)
math.floor({NUM})

#: int operator_mathop_'ceiling' (float NUM)
math.ceil({NUM})

#: int operator_mathop_'sqrt' (float NUM)
math.sqrt({NUM})

#: float operator_mathop_'sin' (float NUM)
math.sin(math.radians({NUM}))

#: float operator_mathop_'cos' (float NUM)
math.cos(math.radians({NUM}))

#: float operator_mathop_'tan' (float NUM)
math.tan(math.radians({NUM}))

#: float operator_mathop_'asin' (float NUM)
math.degrees(math.asin({NUM}))

#: float operator_mathop_'acos' (float NUM)
math.degrees(math.acos({NUM}))

#: float operator_mathop_'atan' (float NUM)
math.degrees(math.atan({NUM}))

#: float operator_mathop_'ln' (float NUM)
math.log({NUM})

# math.log(x, 10) is closer to Scratch's log10
#: float operator_mathop_'log' (float NUM)
math.log({NUM}, 10)

#: float operator_mathop_'e_^' (float NUM)
math.exp({NUM})

#: float operator_mathop_'10_^' (float NUM)
math.pow(10, {NUM})

#: any data_variable (field VARIABLE)
{VARIABLE}

#: stack data_setvariableto (field VARIABLE, any VALUE)
{VARIABLE} = {VALUE}

#: stack data_changevariableby (field VARIABLE, float VALUE)
{VARIABLE} = tonum({VARIABLE}) + {VALUE}

#: stack data_showvariable (field VARIABLE)
print({VARIABLE})

#: stack data_hidevariable (field VARIABLE)
pass # hide variable

#: stack string data_listcontents (field LIST)
str({LIST})

#: stack data_addtolist (any ITEM, field LIST)
{LIST}.append({ITEM})

#: stack data_deleteoflist (any INDEX, field LIST)
{LIST}.delete({INDEX})

#: stack data_deletealloflist (field LIST)
{LIST}.delete_all()

#: stack data_insertatlist (any ITEM, any INDEX, field LIST)
{LIST}.insert({INDEX}, {ITEM})

#: stack data_replaceitemoflist (any INDEX, field LIST, any ITEM)
{LIST}[{INDEX}] = {ITEM}

#: any data_itemoflist (any INDEX, field LIST)
{LIST}[{INDEX}]

#: int data_itemnumoflist (field LIST, any ITEM)
{LIST}.index({ITEM})

#: int data_lengthoflist (field LIST)
len({LIST})

#: bool data_listcontainsitem (field LIST, any ITEM)
{ITEM} in {LIST}

#: data_showlist (field LIST)
{LIST}.show()

#: data_hidelist (field LIST)
{LIST}.hide()

#: code_class
class {name}(Target):
{code}

#: code_var_init
self.{name} = {value}

#:code_var_clone
self.{name} = parent.{name}

#:code_list_init
self.{name} = engine.List(
{items}
)

#: code_costume
{{
    'name': {name},
    'path': {path},
    'center': {center},
    'scale': {scale}
}}

#: code_costumes_init
self.costume = engine.Costumes(
    {costume}, {size}, {rotation}, {costumes})

#: code_sound
{{
    'name': {name},
    'path': {path}
}}

#: code_sounds_init
self.sounds = engine.Sounds(
    {volume}, {sounds})

#: code_info
self._xpos = {xpos}
self._ypos = {ypos}
self._direction = {direction}
self._shown = {visible}
self.pen = engine.Pen(self)

#: code_target_init
def __init__(self, parent=None):
    super().__init__(parent)
    if parent is not None:
        return
{init_code}
    self.sprite._layer = {layer}

#: code_header
import math
import time
import engine
from engine import Target, on_event, warp
from engine.blockutil import *

#: code_sprites
SPRITES = {{
    {items}
}}

#: code_main
if __name__ == '__main__':
    engine.start_program(SPRITES)

# This line is necesary
