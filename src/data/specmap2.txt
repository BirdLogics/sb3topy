"""

"""

import asyncio
import math
import random

import engine

#pylint: disable=all

# flags:
# -d1 Means the sprite will become Dirty after running
# -d2 Means the Rectangle will need updating after running
# -d3 Means the Image will need updating after running
# -s1 Means that dirty must be Set before running the block
# -s2 Means the block accepts and Sets {DIRTY}
# -y  Means the block should Yield after its substack
# -h  Means the block is a Hat and requires special parsing

# -u Means any Updates need to be made before running [Unused]
# Updates are normally performed right before redrawing the screen
# -u flag is currently unused, however the functions with it will
# need to update the sprite(s) themself. For example, the 
# is_touching function will update this and all checked sprites.

# Expression to use for -s1
#: special_dirty
self.set_dirty({DIRTY})

# Expression to use for -y
#: special_yield
await self._yield({DIRTY})

#: special_pen
self.pen.move()

#: procedures_definition (stack SUBSTACK) -h
def {NAME}(self, {PARAMETERS}):{SUBSTACK}

#: any argument_reporter_string_number (any VALUE)
{VALUE}

#: any argument_reporter_boolean (any VALUE)
{VALUE}

#: procedures_call (string NAME, list PARAMETERS) -s1
await {NAME}({PARAMETERS})

#: motion_movesteps (float STEPS) -d2
self.move({STEPS})

#: motion_turnright (float DEGREES) -d3
self.set_direction(self.direction + {DEGREES})

#: motion_turnleft (float DEGREES) -d3
self.set_direction(self.direction - {DEGREES})

#: motion_pointindirection (float DIRECTION) -d3
self.set_direction({DIRECTION})

#: motion_pointtowards (string TOWARDS) -d3
self.point_towards(util, {TOWARDS})

# other = util.targets[{TOWARDS}]
# radians = math.atan2(self.xpos - other.xpos, self.ypos - other.ypos)
# self.set_direction(math.degrees(radians))

#: motion_gotoxy (float X, float Y) -d2
self.xpos = {X}
self.ypos = {Y}

#: motion_goto (string TO) -d2
self.goto(util, {TO})

#: motion_glidesecstoxy (float SECS, float X, float Y) -d2
await self.glide({SECS}, {X}, {Y})

# TODO Glide to target?

#: motion_changexby (float DX) -d2
self.xpos += {DX}

#: motion_setx (float X) -d2
self.xpos = {X}

#: motion_changeyby (float DY) -d2
self.ypos += {DY}

#: motion_sety (float Y) -d2
self.ypos = {Y}

#: motion_ifonedgebounce () -d3
0$ # motion_ifonedgebounce()

#: motion_setrotationstyle (string STYLE) -d3
self.costume.rotation_style = {STYLE}

#: float motion_xposition ()
self.xpos

#: float motion_yposition ()
self.ypos

#: float motion_direction ()
self.direction

#: looks_sayforsecs (string MESSAGE, float SECS)
pass # looks_sayforsecs({MESSAGE}, {SECS})

#: looks_say (string MESSAGE)
pass # looks_say({MESSAGE})

#: looks_thinkforsecs (string MESSAGE, float SECS)
pass # looks_thinkforsecs({MESSAGE, SECS})

#: looks_think (string MESSAGE)
pass # looks_think({MESSAGE})

#: looks_show () -d1
self.visible = 1

#: looks_hide () -d1
self.visible = 0

#: looks_switchcostumeto (any COSTUME) -d3
self.costume.switch({COSTUME})

#: looks_nextcostume () -d3
self.costume.next()

#: looks_switchbackdropto (any BACKDROP) -d3
util.stage.costume.switch({BACKDROP})
util.send_event('onbackdrop_' + util.stage.costume.name, True)

#: looks_switchbackdroptoandwait (any BACKDROP) -d3s1
util.stage.costume.switch({BACKDROP})
await util.send_event('onbackdrop_' + util.stage.costume.name, True)

#: looks_nextbackdrop () -d3
util.stage.costume.next()
util.send_event('onbackdrop_' + util.stage.costume.name, True)

#: looks_changeeffectby (string EFFECT, float CHANGE) -d3
self.costume.change_effect({EFFECT}, {CHANGE})

#: looks_seteffectto (string EFFECT, float VALUE) -d3
self.costume.set_effect({EFFECT}, {VALUE})

#: looks_cleargraphiceffects () -d3
self.costume.clear_effects()

#: looks_changesizeby (float CHANGE) -d3
self.size += {CHANGE}

#: looks_setsizeto (float SIZE) -d3
self.size = {SIZE}

#: looks_gotofrontback (string FRONT_BACK) -d1
#? looks_goto{FRONT_BACK}
pass # looks_gotofrontback()

#: looks_goto'front' ()
self.front_layer(util)

#: looks_goto'back' ()
self.back_layer(util)

# TODO Decimal behavior
#: looks_goforwardbackwardlayers (field FORWARD_BACKWARD, int NUM) -d1
#? looks_go{FORWARD_BACKWARD}layers
0$

#: looks_go'forward'layers (int NUM)
self.change_layer(util, {NUM})

#: looks_go'backward'layers (int NUM)
self.change_layer(util, -{NUM})

#: int looks_costumenumbername (field NUMBER_NAME)
#? looks_costume_{NUMBER_NAME}
0$

#: int looks_costume_'number' ()
self.costume.number

#: string looks_costume_'name' ()
self.costume.name

#: int looks_backdropnumbername (field NUMBER_NAME)
#? looks_backdrop_{NUMBER_NAME}
0$

#: int looks_backdrop_'number' ()
util.stage.costume.number

#: string looks_backdrop_'name' ()
util.stage.costume.name

#: int looks_size ()
round(self.size)

#: sound_play (any SOUND_MENU)
self.sounds.play({SOUND_MENU})

#: sound_playuntildone (any SOUND_MENU) -s1
await self.sounds.play({SOUND_MENU})

#: sound_stopallsounds ()
self.sounds.stop_all(util)

#: sound_changevolumeby (float VOLUME) 
self.sounds.change_volume({VOLUME})

#: sound_setvolumeto (float VOLUME) 
self.sounds.set_volume({VOLUME})

#: float sound_volume ()
self.sounds.volume

#: sound_seteffectto (field EFFECT, float VALUE)
self.sounds.set_effect({EFFECT}, {VALUE})

#: sound_changeeffectby (field EFFECT, float VALUE)
self.sounds.change_effect({EFFECT}, {VALUE})

#: pen_clear ()
self.pen.clear_all()

#: pen_stamp ()
self.pen.stamp()

#: pen_penDown ()
self.pen.down()

#: pen_penUp ()
self.pen.up()

#: pen_setPenColorToColor (any COLOR)
self.pen.set_color({COLOR})

#: pen_changePenColorParamBy (string COLOR_PARAM, float VALUE)
#? pen_change_{COLOR_PARAM}
self.pen.color_set({COLOR_PARAM}, {VALUE})

#: pen_setPenColorParamBy (string COLOR_PARAM, float VALUE)
#? pen_set_{COLOR_PARAM}
self.pen.color_change({COLOR_PARAM}, {VALUE})

#: pen_changePenSizeBy (float SIZE)
self.pen.change_size({SIZE})

#: pen_setPenSizeTo (float SIZE)
self.pen.set_size({SIZE})

# Legacy blocks
#: pen_setPenShadeToNumber (float SHADE)
self.pen.set_shade({SHADE})

#: pen_changePenShadeBy (float SHADE)
self.pen.change_shade({SHADE})

#: pen_setPenHueToNumber (float HUE)
self.pen.set_hue({HUE})

#: pen_changePenHueBy (float HUE)
self.pen.change_hue({HUE})







#: event_whenflagclicked (stack SUBSTACK) -h
green_flag

#: event_whenkeypressed (stack SUBSTACK, string KEY_OPTION) -h
key{KEY_OPTION}_pressed

#: event_whenthisspriteclicked (stack SUBSTACK) -h
sprite_clicked

#: event_whenstageclicked (stack SUBSTACK) -h
sprite_clicked

#: event_whenbackdropswitchesto (stack SUBSTACK, string BACKDROP) -h
onbackdrop_{BACKDROP}

#: event_whengreaterthan (stack SUBSTACK, field WHENGREATERTHANMENU, float VALUE) -h
#? event_whengreaterthan_{WHENGREATERTHANMENU}
event_whengreaterthan

if not {VALUE} > util.timer:
    return

#: event_whenbroadcastreceived (stack SUBSTACK, field BROADCAST_OPTION) -h
broadcast_{BROADCAST_OPTION}

#: event_broadcast (string BROADCAST_INPUT)
util.send_broadcast({BROADCAST_INPUT})

#: event_broadcastandwait (string BROADCAST_INPUT) -s1
await util.send_broadcast({BROADCAST_INPUT})

#: control_wait (float DURATION) -s1
await self.sleep({DURATION})

#: control_repeat (intR TIMES, stack SUBSTACK) -s1y
for _ in range({TIMES}):
{SUBSTACK}

#: control_forever (stack SUBSTACK) -s1y
while True:
{SUBSTACK}

#: control_if (bool CONDITION, stack SUBSTACK) -s1
if {CONDITION}:
{SUBSTACK}

#: control_if_else (bool CONDITION, stack SUBSTACK, stack SUBSTACK2) -s1
if {CONDITION}:
{SUBSTACK}
else:
{SUBSTACK2}

#: control_wait_until (bool CONDITION) -s1
while not {CONDITION}:
    await self._yield()

#: control_repeat_until (bool CONDITION, stack SUBSTACK) -s1y
while not {CONDITION}:
{SUBSTACK}

# TODO Stop other scripts
#: control_stop (field STOP_OPTION)
#? control_stop_{STOP_OPTION}
0$ {STOP_OPTION}

#: control_stop_'this_script' (field STOP_OPTION)
return None

#: control_stop_'other_scripts_in_sprite' (field STOP_OPTION)
self.stop_other()

#: control_stop_'all' (field STOP_OPTION)
util.stop_all()
return None

# TODO Clones
#: control_start_as_clone (stack SUBSTACK) -h
clone_start

#: control_create_clone_of (string CLONE_OPTION)
self.create_clone_of(util, {CLONE_OPTION})

#: control_delete_this_clone ()
self.delete_clone(util)

#: bool sensing_touchingobject (field TOUCHINGOBJECTMENU) -u
#? sensing_touching
self.get_touching(util, {TOUCHINGOBJECTMENU})

# TODO Color detection?
#: bool sensing_touchingcolor (color COLOR) -u
False

#: bool sensing_coloristouchingcolor (color COLOR, color COLOR2) -u
False

#: float sensing_distanceto (field DISTANCETOMENU)
self.distance_to(util, {DISTANCETOMENU})

# TODO sensing_askandwait
#: sensing_askandwait (string QUESTION)
answer = input({QUESTION})

#: sensing_answer
answer

#: bool sensing_keypressed (field KEY_OPTION)
util.get_key({KEY_OPTION})

#: bool sensing_mousedown ()
util.input.m_down

# TODO Mouse stage coords
#: int sensing_mousex ()
util.input.m_xpos

#: int sensing_mousey ()
util.input.m_ypos

#: int sensing_loudness ()
0

#: bool sensing_loud ()
False

# TODO timer
#: float sensing_timer ()
util.timer()

#: sensing_resettimer ()
util.reset_timer()

# TODO {OBJECT} Stage = _stage_
# TODO Properties such 
#: any sensing_of (field PROPERTY, field OBJECT) -v
#? sensing_{PROPERTY}_of
util.targets[{OBJECT}].{PROPERTY}

#: float sensing_x_position_of
util.targets[{OBJECT}].xpos

#: float sensing_y_position_of
util.targets[{OBJECT}].ypos

#: float sensing_direction_of
util.targets[{OBJECT}].direction

#: int sensing_costume_#_of
util.targets[{OBJECT}].costume.number

#: string sensing_costume_name_of
util.targets[{OBJECT}].costume.name

#: int sensing_size_of
round(util.targets[{OBJECT}].size)

#: float sensing_volume_of
util.targets[{OBJECT}].volume

#: int sensing_backdrop_#_of
round(util.targets[{OBJECT}].costume.number)

#: string sensing_backdrop_name_of
util.targets[{OBJECT}].costume.name

#: int sensing_current (field CURRENT_MENU)
#? sensing_current_{CURRENT_MENU}
0

#: sensing_current_'year'
time.localtime()['tm_year']

#: sensing_current_'month'
time.localtime()['tm_month']

#: sensing_current_'date'
time.localtime()['tm_mday']

#: sensing_current_'day of week'
(time.localtime()['tm_wday'] + 2)

#: sensing_current_'hour'
time.localtime()['tm_hour']

#: sensing_current_'minute'
time.localtime()['tm_min']

#: sensing_current_'second'
time.localtime()['tm_sec']

# TODO Diffrent epoches?
#: float sensing_dayssince2000 ()
(time.time() / 86400 - 10957)

#: string sensing_username ()
engine.USERNAME

#: float operator_add (float NUM1, float NUM2)
({NUM1} + {NUM2})

#: float operator_subtract (float NUM1, float NUM2)
({NUM1} - {NUM2})

#: float operator_multiply (float NUM1, float NUM2)
({NUM1} * {NUM2})

#: float operator_divide (any NUM1, any NUM2)
div({NUM1}, {NUM2})

#: float operator_random (float FROM, float TO)
randrange({FROM}, {TO})

# TODO Only string if one can't be casted
#: bool operator_lt (any OPERAND1, any OPERAND2)
lt({OPERAND1}, {OPERAND2})

#: bool operator_equals (any OPERAND1, any OPERAND2)
eq({OPERAND1}, {OPERAND2})

#: bool operator_gt (any OPERAND1, any OPERAND2)
gt({OPERAND1}, {OPERAND2})

#: bool operator_and (bool OPERAND1, bool OPERAND2)
({OPERAND1} and {OPERAND2})

#: bool operator_or (bool OPERAND1, bool OPERAND2)
({OPERAND1} or {OPERAND2})

#: bool operator_not (bool OPERAND)
not {OPERAND}

# TODO Limited length join
#: string operator_join (string STRING1, string STRING2)
({STRING1} + {STRING2})

#: string operator_letter_of (intF LETTER, STRING)
engine.letter({STRING}, {LETTER})

#: int operator_length (string STRING)
len(str({STRING}))

#: bool operator_contains (string STRING1, string STRING2)
({STRING2} in {STRING1})

#: float operator_mod (float NUM1, float NUM2)
({NUM1} % {NUM2})

#: int operator_round (float NUM)
round({NUM})

#: float operator_mathop (string OPERATOR, float NUM)
#? operator_mathop_{OPERATOR}
number({NUM})$

#: int operator_mathop_'abs' (float NUM)
abs({NUM})

#: int operator_mathop_'floor' (float NUM)
math.floor({NUM})

#: int operator_mathop_'ceiling' (float NUM)
math.ceil({NUM})

#: int operator_mathop_'sqrt' (float NUM)
math.sqrt({NUM})

#: float operator_mathop_'sin' (float NUM)
math.sin(math.radians({NUM}))

#: float operator_mathop_'cos' (float NUM)
math.cos(math.radians({NUM}))

#: float operator_mathop_'tan' (float NUM)
math.tan(math.radians({NUM}))

#: float operator_mathop_'asin' (float NUM)
math.degrees(math.asin({NUM}))

#: float operator_mathop_'acos' (float NUM)
math.degrees(math.acos({NUM}))

#: float operator_mathop_'atan' (float NUM)
math.degrees(math.atan({NUM}))

#: float operator_mathop_'ln' (float NUM)
math.log({NUM})

#: float operator_mathop_'log' (float NUM)
math.log10({NUM})

#: float operator_mathop_'e_^' (float NUM)
math.exp({NUM})

#: float operator_mathop_'10_^' (float NUM)
math.pow(10, {NUM})

#: any data_variable (field VARIABLE, field PREFIX)
{PREFIX}.{VARIABLE}

#: data_setvariableto (field VARIABLE, any VALUE, field PREFIX)
{PREFIX}.{VARIABLE} = {VALUE}

#: data_changevariableby (field VARIABLE, float VALUE, field PREFIX)
{PREFIX}.{VARIABLE} = number({PREFIX}.{VARIABLE}) + {VALUE}

#: data_showvariable (field VARIABLE, field PREFIX)
print({PREFIX}.{VARIABLE})

#: data_hidevariable (field VARIABLE, field PREFIX)
pass # hide variable

#: string data_listcontents (field LIST, field PREFIX)
str({PREFIX}.{LIST})

#: data_addtolist (any ITEM, field LIST, field PREFIX)
{PREFIX}.{LIST}.append({ITEM})

#: data_deleteoflist (any INDEX, field LIST, field PREFIX)
{PREFIX}.{LIST}.delete({INDEX})

#: data_deletealloflist (field LIST, field PREFIX)
{PREFIX}.{LIST}.delete_all()

#: data_insertatlist (any ITEM, any INDEX, field LIST, field PREFIX)
{PREFIX}.{LIST}.insert({INDEX}, {ITEM})

#: data_replaceitemoflist (any INDEX, field LIST, any ITEM, field PREFIX)
{PREFIX}.{LIST}[{INDEX}] = {ITEM}

#: any data_itemoflist (any INDEX, field LIST, field PREFIX)
{PREFIX}.{LIST}[{INDEX}]

#: int data_itemnumoflist (field LIST, any ITEM, field PREFIX)
{PREFIX}.{LIST}.index({ITEM})

#: int data_lengthoflist (field LIST, field PREFIX)
len({PREFIX}.{LIST})

#: bool data_listcontainsitem (field LIST, any ITEM, field PREFIX)
{ITEM} in {PREFIX}.{LIST}

#: data_showlist (field LIST, field PREFIX)
{PREFIX}.{LIST}.show()

#: data_hidelist (field LIST, field PREFIX)
{PREFIX}.{LIST}.hide()

#: code_var_init
self.{name} = {value}

#:code_var_clone
self.{name} = parent.{name}

#:code_list_init
self.{name} = engine.List(
{items}
)

#:code_list_clone
self.{name} = parent.{name}.copy()

#: code_costume
{{
    'name': {name},
    'path': {path},
    'center': {center},
    'scale': {scale}
}}

#: code_costumes_init
self.costume = engine.Costumes(
    {costume}, {rotation}, {costumes})

#: code_sound
{{
    'name': {name},
    'path': {path}
}}

#: code_sounds_init
self.sounds = engine.Sounds(
    {volume}, {sounds})

#: code_assets_clone
self.costume = parent.costume.copy()
self.sounds = parent.sounds.copy()

#: code_info
self.xpos = {xpos}
self.ypos = {ypos}
self.direction = {direction}
self.size = {size}
self.visible = {visible}
self.pen = Pen(util, self)

#: code_info_clone
self.xpos = parent.xpos
self.ypos = parent.ypos
self.direction = parent.direction
self.size = parent.size
self.visible = parent.visible
self.pen = parent.pen.copy(self)

#: code_hat
{name}: [
{hats}
]

#: code_hats_dict
self.hats = {{
{hats}
}}

#: code_target_init
def __init__(self, util, parent=None):
    super().__init__(util, parent)
    if parent is None:
{init_code}
    else:
{clone_code}
{hats}
    self.sprite._layer = {layer}
    self.update(util)

if __name__ == '__main__':
    pass
